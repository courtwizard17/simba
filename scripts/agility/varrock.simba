program varrockhopper;
{$I WaspLib/osr.simba}
{$I ../Includes/BHI.simba}

begin
  Login.PlayerIndex := 0;
end;

const
  BREAKAFTER  = 40;
  BREAKFOR    = 5;
  MINHP       = 10;
  FOODNAME    = 'Lobster';

  BIRDHOUSES  = True;
  INTERVAL    = 10 * ONE_MINUTE;
  SEED        = 'Onion seed';

type
  TObstacle = record
    Index: Int32;
    Tile: TPoint;
    UpText: TStringArray;
    Area: TBox;
    Color: TCTS2Color;
    Height: Int32;
  end;

var
  HopperRSW: TRSWalker;
  Timer, ReportTimer: TStopwatch;
  StartXP, CurrentXP, GainedXP, Marks, Step: Int32;
  Obstacles: Array [0..8] of TObstacle;
  Food: TRSItem;
  BankObject: TRSObject;
  ReturnSpell: ERSSpell;
  RuneArray: TRSItemArray;
  Logs: ERSLogType;

procedure PauseTimer(Task: PBreakTask);
var T: PBreakTask;
begin
  Timer.Pause;
  T := Task;
end;

procedure ResumeTimer(Task: PBreakTask);
var T: PBreakTask;
begin
  Timer.Resume;
  T := Task;
end;

procedure CalculateXP();
var
  t: Int32;
begin
  CurrentXP := XPBar.Read();
  t         := GainedXP;
  GainedXP  := (CurrentXP - StartXP);

  if GainedXP > t then
    Timer.Reset();

  if Timer.ElapsedTime > 300000 then
    TerminateScript('No Gained XP in 5 minutes!');
end;

procedure WriteDebug(Message: String);
begin
  WriteLn(SRL.TimeStamp(), ':[Script]: ', Message);
end;

procedure PrintProgress();
var
  hrs: Double;
  s1, s3: String;
begin
  hrs := (GetTimeRunning()/3600000);
  s1 := ToStr(Round((GainedXP/1000), 0), ' k ');
  s3 := ToStr('(', Round((GainedXP/(hrs*1000)), 1), ' k / hr)');
  WriteLn(SRL.TimeStamp(), ':[Experience]: ', s1, s3);
  ReportTimer.Reset();
end;

procedure KeyboardRotate();
var
  Arrow: Integer;
  Duration: Int64;
begin
  if SRL.Dice(50) then
    Arrow := $25
  else
    Arrow := $27;
  Duration := SRL.NormalRange(250, 2250);
  Keyboard.KeyDown(Arrow);
  Sleep(Duration);
  Keyboard.KeyUp(Arrow);
end;

procedure HealthManagement();
begin
  if not RSClient.IsLoggedIn() then
    Exit();
  if Minimap.GetHPLevel() < MINHP then
    begin
      if Inventory.ContainsItem(Food) then
        Inventory.ClickItem(Food)
      else
        TerminateScript('Could not eat food, possible out of it?');
    end;
end;

procedure TAntiban.DoLoseFocus();
begin
  Self.LoseFocus(SRL.NormalRange(800,3500));
end;

function TRectangle.RandomMean(): TPoint;
var
  centerX, centerY, randX, randY: Double;
begin
  centerX := Self.Mean().X;
  centerY := Self.Mean().Y;

  randX := Self.Left.X + Random * (Self.Right.X - Self.Left.X);
  randY := Self.Top.Y + Random * (Self.Btm.Y - Self.Top.Y);

  Result.X := Trunc((centerX + randX) / 2);
  Result.Y := Trunc((centerY + randY) / 2);
end;

procedure SetupAntiban();
begin
  Antiban.Skills := [ERSSKILL.AGILITY, ERSSKILL.TOTAL];
  Antiban.AddTask(ONE_MINUTE*2,   @Mouse.RandomMovement);
  Antiban.AddTask(ONE_MINUTE*6,   @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*3,   @Antiban.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*7,   @Antiban.RandomRotate);
  Antiban.AddTask(ONE_MINUTE*7,   @KeyboardRotate);
  Antiban.AddTask(ONE_MINUTE*8,   @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*25,  @Antiban.HoverSkills);
  Antiban.AddBreak(ONE_SECOND * 100, ONE_SECOND * 8, 0.3, 0);
  Antiban.AddBreak(BREAKAFTER * ONE_MINUTE, BREAKFOR * ONE_MINUTE, 0.3, 1);
  Antiban.OnStartBreak := @PauseTimer;
  Antiban.OnFinishBreak := @ResumeTimer;
end;

procedure InitiateScript();
begin
  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();
  WaitUntil(RSClient.IsLoggedIn(), 250, 12000);

  StartXP := XPBar.Read();

  if StartXP < 69 then
    TerminateScript('Failed to read XP, make sure XPBar is set up!');

  Options.SetNPCAttackOption(ERSAttackOption.HIDDEN);
  Options.SetZoomLevel(Random(0, 6));

  if BIRDHOUSES then
  begin
    Logs := BirdHouseRunner.GetLogForHunterLevel(Stats.GetLevel(ERSSkill.HUNTER, False));
    WriteLn('Logtype for birdhouses based on level: ', ToStr(Logs));
    BirdHouseRunner.Setup(Logs, SEED, False, INTERVAL, False);
    BirdHouseRunner.Init();
  end;

  HopperRSW.Setup();
  SetupAntiban();

  BankObject.SetupUpText(['Bank','Bank booth']);
  BankObject.Setup(6, [[8136, 2704]]);
  BankObject.Finder.Colors += CTS2(4880003, 11, 0.03, 1.38);
  RuneArray := ['Law rune', 'Fire rune', 'Air rune'];
  ReturnSpell := ERSSpell.VARROCK_TELEPORT;

  Mouse.Speed := SRL.NormalRange(12, 18);
  Food := FOODNAME;

  with Obstacles[0] do
  begin
    Index := 0;
    Tile := [8276, 2792];
    UpText := ['Climb R', 'ough'];
    Height := 2;
    Area := [8000, 2500, 9000, 3100];
  end;
  with Obstacles[1] do
  begin
    Index := 1;
    Tile := [306, 4908];
    UpText := ['Cross', 'othe'];
    Height := 0;
    Area := [302, 4882, 346, 4931];
  end;
  with Obstacles[2] do
  begin
    Index := 2;
    Tile := [254, 4900];
    Height := 0;
    UpText := ['Leap', 'eap G'];
    Area := [253, 4877, 291, 4913];
  end;
  with Obstacles[3] do
  begin
    Index := 3;
    Height := 0;
    Tile := [582, 4906];
    UpText := ['Balance W', 'ce W'];
    Area := [578, 4894, 620, 4924];
  end;
  with Obstacles[4] do
  begin
    Index := 4;
    Height := 0;
    Tile := [238, 4960];
    UpText := ['Leap', 'Gap'];
    Area := [212, 4932, 254, 4961];
  end;
  with Obstacles[5] do
  begin
    Index := 5;
    Height := 0;
    Tile := [290, 4964];
    UpText := ['Leap', 'Gap'];
    Area := [165, 4951, 300, 5069];
  end;
  with Obstacles[6] do
  begin
    Index := 6;
    Height := 0;
    Tile := [386, 4956];
    UpText := ['eap', 'Gap'];
    Area := [301, 4935, 395, 5020];
  end;
  with Obstacles[7] do
  begin
    Index := 7;
    Height := 2;
    Tile := [406, 4928];
    UpText := ['Hurdle', 'edge'];
    Area := [390, 4932, 426, 5000];
  end;
  with Obstacles[8] do
  begin
    Index := 8;
    Tile := [402, 4900];
    Height := 0;
    UpText := ['ump-', 'Edge'];
    Area := [386, 4891, 435, 4929];
  end;

  StartXP := XPBar.Read();
  Timer.Start();
  ReportTimer.Start();
end;

procedure DrawNeonRectangle(Rect: TRectangle);
var
  RR,RG,RB,
  R,G,B,i: Integer;
  Pts: TPointArray;
  Cols: TIntegerArray;
  Color: Integer := 9442932;
begin
  ColorToRGB(Color, RR, RG, RB);
  try
    Pts := TPAFromPolygon(Rect.ToTPA);
    Cols := GetColors(Pts);

    for i:=0 to high(Cols) do
    begin
      ColorToRGB(Cols[i], R, G, B);
      R := Round(0.01 * (70 * R + 30 * RR));
      G := Round(0.01 * (70 * G + 30 * RG));
      B := Round(0.01 * (70 * B + 30 * RB));
      RSClient.Image.DrawTPA([Pts[i]], RGBtoColor(R,G,B));
    end;
  except
  end;
end;

function GetStep(): Int32;
var
  Pos: TPoint := HopperRSW.GetMyPos();
  i: Int32;
begin
  for i := 0 to High(Obstacles) do
    if Obstacles[i].Area.Contains(Pos) then
      Exit(i);

  Exit(-1);
end;

function FindObstacle(Obs: TObstacle): Boolean;
var
  Pt: TPoint;
  MSRect: TRectangle;
  TPA: TPointArray;
  Bds: TBox;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  MSRect := HopperRSW.GetTileMS(Obs.Tile, Obs.Height);
  Bds := MSRect.Bounds().Expand(2);

  if not Mainscreen.Bounds.Contains(Bds) then
    Exit(False);

  DrawNeonRectangle(MSRect);

  if Obs.Color.Color <> 0 then
  begin
    SRL.FindColors(TPA, Obs.Color, Bds);

    if TPA.Len() < 1 then
      Exit(False);

    for 1 to SRL.NormalRange(2, 4) do
    begin
      Pt := TPA.RandomValue();
      Mouse.HumanMove(Pt);
      if Mainscreen.IsUpText(Obs.UpText, 175) then
        Exit(True);
    end;

  end else
  begin
    for 1 to SRL.NormalRange(2, 4) do
    begin
      Pt := MSRect.RandomMean();
      Mouse.HumanMove(Pt);
      if Mainscreen.IsUpText(Obs.UpText, 175) then
        Exit(True);
    end;
  end;

  Result := Mainscreen.IsUpText(Obs.UpText, 175);
end;

procedure GroundStep();
var
  Found: Boolean;
  Pos, StartTile: TPoint;
  xp: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if BIRDHOUSES then
    if BirdHouseRunner.CanDoBirdHouseRun() then
      BirdHouseRunner.DoBirdHouseRun();

  Found := FindObstacle(Obstacles[0]);
  RSClient.Image.Clear();

  if Found then
  begin
    xp := XPBar.Read();
    Mouse.Click(MOUSE_LEFT);
    WaitUntil(xp < XPBar.Read(), 250, 12775);
  end else
  begin
    Pos := HopperRSW.GetMyPos();
    StartTile := [Obstacles[0].Tile.X + 4, Obstacles[0].Tile.Y];

    if Pos.DistanceTo(StartTile) > 32 then
      HopperRSW.WalkBlind(StartTile)
    else
    begin
      if SRL.Dice(50) then
        KeyboardRotate()
      else
        Antiban.RandomRotate();
    end;
  end;
end;

procedure PickMarks(Step: Int32);
var
  MRect: TRectangle;
  MTPA, Dots: TPointArray;
  Dot: TPoint;
  MoGColor: TCTS2Color := CTS2(2141119, 1, 0.01, 0.01);
  MBds: TBox;
  MoG: Int32;
begin
  WaitEx(555,  225);
  Dots := Minimap.GetDots(ERSMinimapdot.ITEM);
  if Dots.Len() > 0 then
  begin
    Dot := Dots[0];
    Dot := HopperRSW.MMToWorld(Dot);
    if Obstacles[Step].Area.Contains(Dot) then
    begin
      MRect := HopperRSW.GetTileMS(Dot).Expand(4);
      DrawNeonRectangle(MRect);
      MBds := MRect.Bounds();
      MBds.LimitTo(Mainscreen.Bounds());
      SRL.FindColors(MTPA, MoGColor, MBds);
      if MTPA.Len() > 0 then
      begin
        MoG := Inventory.CountItemStack('Mark of grace');
        Mouse.HumanMove(MTPA.Mean());
        WaitEx(55, 25);
        if Mainscreen.IsUpText(['Take M', 'ark of g']) then
        begin
          RSClient.Image.Clear();
          Mouse.Click(MOUSE_LEFT);

          if not WaitUntil(MoG < Inventory.CountItemStack('Mark of grace'), 250, 7500) then
            Exit();

          Marks += 1;
          WaitEx(420, 69);
        end;
      end;
    end;
  end;
end;

procedure NormalStep(Step: Int32);
var
  Found: Boolean;
  hp, xp: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  hp := Minimap.GetHPLevel();
  xp := XPBar.Read();
  PickMarks(Step);
  Found := FindObstacle(Obstacles[Step]);
  RSClient.Image.Clear();

  if Found then
  begin
    Mouse.Click(MOUSE_LEFT);
    WaitUntil((xp < XPBar.Read()) or (hp > Minimap.GetHPLevel()), 250, 12775);
  end else
  begin
    KeyboardRotate();
    Found := FindObstacle(Obstacles[Step]);
    RSClient.Image.Clear();
    if Found then
    begin
      Mouse.Click(MOUSE_LEFT);
      WaitUntil((xp < XPBar.Read()) or (hp > Minimap.GetHPLevel()), 250, 12775);
    end else
      HopperRSW.WalkBlind(Obstacles[Step].Tile);
  end;
end;

procedure RecoverFromLost();
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if Timer.ElapsedTime > 40000 then
  begin
    Magic.CastSpell(ReturnSpell);
    WaitEx(5250, 225);
  end else
    WriteLn('Lost');
end;

procedure ScriptLoop();
begin
  Antiban.DoAntiban();

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  if Mainscreen.HasInterface() then
    Mainscreen.CloseInterface(50);

  HealthManagement();
  Step := GetStep();
  CalculateXP();

  if ReportTimer.ElapsedTime > 60000 then
    PrintProgress();

  if Step = -1 then
    RecoverFromLost()
  else if Step = 0 then
    GroundStep()
  else if Step > 0 then
    NormalStep(Step);
end;

function TBirdHouseInclude.OnStart() : Boolean; override;
var
  i, j: Int32;
  bankTimeout : TCountdown;
  FoodBankItem, RuneBankItem: TRSBankItem;
begin
  Writeln("Birdhouse Include OnStart");

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Pause();

  bankTimeout.Init(65000);

  while not bankTimeOut.IsFinished() and not Bank.IsOpen() do
  begin
    BankObject.WalkClick();
    WaitUntil(Bank.IsOpen(), 250, 2000);
  end;

  if not Bank.IsOpen() then
  begin
    Self.DebugLn("Failed to get to bank");
    Exit(false);
  end;

  if Inventory.CountEmptySlots() < 28 then
  begin
    Bank.DepositAll();
    WaitUntil(Inventory.CountEmptySlots() > 25, 150, 2000);

    if not Self.WithdrawNextRun() then
    begin
      Self.DebugLn("Failed to get bank items");
      Bank.DepositAll();
      Bank.Close();
      BirdhouseRunner.IsDisabled := true;
      Exit(false);
    end;

    for j := 0 to High(RuneArray) do
    begin
      RuneBankItem := TRSBankItem.Setup(RuneArray[j], 10, False);
      Bank.WithdrawItem(RuneBankItem, False);
      WaitEx(500, 450);
    end;

    FoodBankItem := TRSBankItem.Setup(Food, 2, False);
    Bank.WithDrawItem(FoodBankItem, False);

    WaitEx(325, 250);

    Bank.Close(60);
  end;

  Result := true;
end;

procedure TBirdHouseInclude.OnComplete(); override;
var
  i: Int32;
begin
  Self.DebugLn("Birdhouse Include OnComplete");

  ScriptWalker := @HopperRSW;
  Magic.CastSpell(ReturnSpell);
  WaitEx(6969, 420);

  for i := 0 to High(Antiban.Tasks) do
    Antiban.Tasks[i].Countdown.Resume();
end;

begin
  InitiateScript();
  repeat
    begin
      ScriptLoop();
      WaitEx(450, 325);
    end;
  until false;
end.