(*
  Include file for handling farm runs and birdhouse runs
  Original Birdhouse Runner by CanadianJames
  Original Farming Run include by XJ and Student
  Modified by n0ll
*)

{$DEFINE CJ_BIRDHOUSE_RUNNER}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}
{$IFNDEF ANDREW_MUSHTREE_INCLUDED}
  {$I WaspLib/optional/interfaces/mainscreen/mushtree.simba}
{$ENDIF}
{$IFNDEF SKUNK_UNIVERSAL_TRANSPORT}
  {$I Includes\WaspLib\optional\handlers\teleports\transport.simba}
{$ENDIF}

{$SCOPEDENUMS ON}

type
  EFarmPatch = (CATHERBY_HERB, CATHERBY_FLOWER, ARDY_HERB, ARDY_FLOWER,
                HOSIDIOUS_HERB, HOSIDIOUS_FLOWER, FALLY_HERB, FALLY_FLOWER);
  ETravelMethod = (CAMELOT_TELEPORT, HOUSE_TELEPORT, FALADOR_TELEPORT, ARDOUGNE_TELEPORT, NONE);
  ECompostMethod = (ULTRA, BOTTOMLESS);
  EPatchType = (HERB, FLOWER);
  EPatchState = (TELEPORT_TO, DEAD, DISEASED, HARVEST, PLANT, COMPOST, NOTE_ITEMS, FAILED, COMPLETE, SKIP);

  TPatchData = record
    BorderColor, SoilColor, LeprechaunColor: TCTS2Color;
    Coords, LeprechaunCoords: TPoint;
    PatchType: EPatchType;
    MapCoords: TBox;
    Name: String;
  end;

  TFarmPatch = record
    EmptyUpText, PlantedUpText, HarvestUpText: String;
    TravelMethod: ETravelMethod;
    Data: TPatchData;
    TPA: TPointArray;
    SearchBox: TBox;
    Seed: TRSItem;
    Complete, Skip: Boolean;
  end;

  TFarmRunner = record
    PatchesCompleted, PatchesSkipped, MaxRuns, RunsComplete, XPGained, LastXPRead: Int32;
    HosidiusFlower, HosidiusHerb, FaladorFlower, FaladorHerb, ArdougneFlower, BDibber,
    ArdougneHerb, CatherbyFlower, CatherbyHerb, MSecs, StartWithRun: Boolean;
    InactivityTimer, ReadyTimer: TCountdown;
    HarvestQuantities: TIntegerArray;
    FarmItemAmounts: TIntegerArray;
    LeprechaunItems: TRSItemArray;
    CompostMethod: ECompostMethod;
    Patches: array of TFarmPatch;
    CurrentPatch: TFarmPatch;
    FarmItems: TRSItemArray;
    Runtime: TStopWatch;
    HerbSeed: TRSItem;
  end;

  ERSLogType = (REGULAR_LOGS, OAK_LOGS, WILLOW_LOGS, TEAK_LOGS, MAPLE_LOGS, MAHOGANY_LOGS, YEW_LOGS, MAGIC_LOGS, REDWOOD_LOGS);
  EScriptState = (DO_NOTHING, TELEPORTING, NAVIGATING, CLICK_MUSHROOM, USE_MUSHROOM, BUILD_BIRDHOUSE, INTERACT_BIRDHOUSES );
  EScriptAfterState = (NOTHING, WALK_BANK, WITHDRAW_NEXT_RUN, TAKING_BOAT, WALK_MUSHROOM, TELEPORT_MUSHROOM, FINISHED );
  ERSMushroomLocation = (VERD_VALLEY, HILL_HOUSE, SHROOM_MEADOW);

  TBirdhouse = record
    BirdhouseObject : TRSObject;
    IsFilled : Boolean;
  end;

  TMushroom = record
    Mushroom : TRSObject;
    location : ERSMushroomLocation;
  end;
{$SCOPEDENUMS OFF}

  CurrBirdhouse = ^TBirdhouse;

  TBirdHouseInclude = record
    LogType, SuggestedLogType: ERSLogType;
    Seed: TRSItem;
    BirdHousesFilled: Int8;
    TaskInterval : Uint32;
    CurrentBirdHouse : CurrBirdhouse;
    HasRunStarted, HasRunFinished, ShouldTeleport, AlwaysUseBestLog, IsDisabled,
    NeedClockworks, TerminateOnNoLogs, Initialized: Boolean;
    RSW: TRSWalker;
    ScriptIntervalTimer, NextRunSpewTimer: TCountdown;
    VerdValleyShroom, MushMeadowShroom, HouseHillShroom: TRSObject;
    MushIndex: Int8;
    RunsCompleted: Int32;
    NestsLooted: Int32;
    RunStartXp, TotalXPEarned: UInt64;
    Mushrooms: array of TMushroom;
    birdHouses: array of TBirdhouse;
    State: EScriptState;
    EndScriptState: EScriptAfterState;
  end;

var
  BirdHouseRunner: TBirdHouseInclude;
  FarmRunner: TFarmRunner;
  BHIncludeGUILogType: ERSLogType := ERSLogType.MAPLE_LOGS;
  BHIncludeGUISeed: TRSItem := 'Potato seed';
  BHIncludeGUIRunIntervalMinutes: Int32 := 51;
  PatchData: array of TPatchData;

function TMushroom.GetMushButton() : ERSMushTreeButton;
begin
  case Self.location of
    ERSMushroomLocation.HILL_HOUSE : Result := ERSMushTreeBUtton.VERDANT_VALLEY;
    ERSMushroomLocation.VERD_VALLEY : Result := ERSMushTreeBUtton.MUSHROOM_MEADOW;
    ERSMushroomLocation.SHROOM_MEADOW : Result := ERSMushTreeBUtton.HOUSE_ON_THE_HILL;
  end;
end;

function TRSMushTree.Click(mushroom : ERSMushTreeButton) : Boolean;
begin
  Result := Self.GetButton(mushroom).Click();
end;

function TBirdHouseInclude.GetNewRunInterval() : Uint64;
begin
  Result := Round(Random(Self.TaskInterval * 1.043598435, Self.TaskInterval * 1.35))
end;

procedure TBirdHouseInclude.DebugLn(message : string);
begin
  WriteLn(SRL.TimeStamp() + ':[' + 'Birdhouses' + ']: ' + message);
end;

procedure TFarmRunner.DebugLn(message : string);
begin
  WriteLn(SRL.TimeStamp() + ':[' + 'Farms' + ']: ' + message);
end;

function TBirdHouseInclude.GetBirdHouseSpace() : TPointArray;
const
  SPACE_COLOR : TCTS2Color := CTS2(9029, 1, 0.01, 0.01);
var
  ATPA : T2DPointArray;
  msC : TPoint := Mainscreen.Center;
begin
  SRL.FindColors(Result, SPACE_COLOR, Mainscreen.Bounds);
  Result := Result.Grow(3);
  ATPA := Result.Cluster(10);
  ATPA := ATPA.SortFrom(msC);

  if ATPA.Len() < 1 then
    Result := []
  else
    Result := ATPA[0];
end;

function TBirdHouseInclude.GetLogString(log : ERSLogType) : string;
begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := "Logs";
    else
      Result := ToStr(Log).Before("_") + " logs";
  end;
end;

function TBirdHouseInclude.GetBirdhouseItem(log : ERSLogType) : TRSItem;
var
  baseBirdHouse : TRSItem := "Bird house";
begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := baseBirdHouse;
    else
      Result := ToStr(Log).Before("_") + " " + baseBirdHouse;
  end;
end;

function TBirdHouseInclude.GetWithdrawList() : TRSBankItemArray;
begin
  Result += TRSBankItem.Setup("Chisel", 1, false);
  Result += TRSBankItem.Setup("Hammer", 1, false);
  Result += TRSBankItem.Setup(Self.GetLogString(Self.LogType), 4, false);

  if Self.NeedClockworks then
    Result += TRSBankItem.Setup("Clockwork", 1, false);

  Result += TRSBankItem.Setup(Self.Seed, 40, false);
end;

function TRSBank.FindAll(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if not Self.FindItem(tempItem, tempBox) then
      Exit(false);
  end;

  Result := true;
end;

function TRSBankItemArray.ToItemArray(): TRSItemArray; constref;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    Result += Self[i].Item;
end;

function TBirdHouseInclude.HasTools() : Boolean;
var
  tools: TRSItemArray;
  i: Int32;
begin
  if (Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)))
  or (not Self.NeedClockworks and Inventory.ContainsItem(Self.GetLogString(Self.LogType))) then
    Exit(true);

  //Can't count seeds while the slot is selected.
  if Inventory.GetSelectedSlot() = -1 then
    Exit(true);

  tools := ['Chisel', 'Hammer'];

  if (not Inventory.ContainsItem(Self.GetLogString(Self.LogType))
  or not Inventory.ContainsItem('Clockwork')) then
  begin
    Self.DebugLn("Missing birdhouse, log, or clockwork");
    Exit(false);
  end;

  for i := 0 to High(tools) do
  begin
    if not Inventory.ContainsItem(tools[i]) then
    begin
      Self.DebugLn("Missing item: " + ToStr(tools[i]));
      Exit(false);
    end;
  end;

  i := Inventory.CountItemStack(Self.Seed);
  Result :=  i >= 5;
  if not Result then
    Self.DebugLn("Seed count: " + ToStr(i));

end;

procedure TBirdHouseInclude.SetupBirdHouses();
var
  VVBHN, VVBHS, MMBHN, TARBH : TRSObject;
  commonFinder : TRSObjectFinder;
begin

  SetLength(Self.birdHouses, 4);

  //Regular
  commonFinder.ColorClusters += [CTS2(1789275, 5, 0.10, 0.69), CTS2(6201021, 8, 0.03, 1.40), 20];
  //Oak
  commonFinder.ColorClusters += [CTS2(5074823, 15, 0.05, 0.33), CTS2(8561589, 7, 0.04, 1.08), 20];
  //Willow
  commonFinder.ColorClusters += [CTS2(2314071, 7, 0.06, 0.42), CTS2(3366502, 7, 0.06, 1.61), 20];
  //Teak
  commonFinder.ColorClusters += [CTS2(3495271, 9, 0.12, 0.20), CTS2(6848914, 4, 0.31, 0.40), 20];
  //Maple
  commonFinder.ColorClusters += [CTS2(2378868, 8, 0.14, 0.18), CTS2(2710661, 5, 0.08, 0.36), 20];
  //Mahogany
  commonFinder.ColorClusters += [CTS2(1065831, 3, 0.15, 1.31), CTS2(3425125, 4, 0.10, 0.33), 20];
  //Yew
  commonFinder.ColorClusters += [CTS2(11332, 3, 0.08, 0.01), CTS2(476757, 7, 0.19, 2.44), 20];
  //Magic
  commonFinder.ColorClusters += [CTS2(7962919, 9, 0.03, 0.29), CTS2(10922399, 14, 0.12, 0.17), 20];
  //Redwood
  commonFinder.ColorClusters += [CTS2(604522, 8, 0.22, 2.05), CTS2(4154261, 6, 0.05, 0.13), 20];
  commonFinder.ClusterDistance := 10;

  with VVBHN do
  begin
    SetupCoordinates([ [9471, 1252] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with VVBHS do
  begin
    SetupCoordinates([ [9446, 1276] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with MMBHN do
  begin
    SetupCoordinates([ [9107, 769] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with TARBH do
  begin
    SetupCoordinates([ [9114, 1034] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  Self.birdHouses[0] := [VVBHN, false];
  Self.birdHouses[1] := [VVBHS, false];
  Self.birdHouses[2] := [MMBHN, false];
  Self.birdHouses[3] := [TARBH, false];
end;

function TBirdHouseInclude.GetHouseOnHillRegion() : TBox;
begin
  Result := Box(10024, 865, 10314, 1114)
end;

function TBirdHouseInclude.GetNearestUnfilledBirdHouse(myPos : TPoint; out bestIndex : Int32) : Boolean;
var
  dist : Int32;
  bestDist : Int32 = 99999;
  i : Int8;
begin
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      continue;

    dist := Distance(Self.birdHouses[i].BirdhouseObject.Coordinates[0], myPos);

    if dist < bestDist then
    begin
      bestDist := dist;
      bestIndex := i;
      Result := true;
    end;
  end;
end;

procedure TBirdHouseInclude.Init();
var
  VerdValleyShroom, MushMeadowShroom, HouseHillShroom : TMushroom;
begin
  Self.DebugLn('Init');

  if Self.IsDisabled then
    Exit;

  Self.RSW.SetupRegions([RSRegions.FOSSIL_ISLAND, Self.GetHouseOnHillRegion()]);
  Self.RSW.AdaptiveWalk := true;
  RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES := Point(Random(6, 12), Random(6, 12));

  with HouseHillShroom.Mushroom do
  begin
    Setup(16, [ [10158, 948] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with VerdValleyShroom.Mushroom do
  begin
    Setup(16, [[9426, 1272]]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with MushMeadowShroom.Mushroom do
  begin
    Setup(16, [ [9106, 812] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  HouseHillShroom.location := ERSMushroomLocation.HILL_HOUSE;
  VerdValleyShroom.location := ERSMushroomLocation.VERD_VALLEY;
  MushMeadowShroom.location := ERSMushroomLocation.SHROOM_MEADOW;

  Self.Mushrooms := [HouseHillShroom, VerdValleyShroom, MushMeadowShroom];
  Self.MushIndex := 0;

  Self.ShouldTeleport := true;

  Self.SetupBirdHouses();
  Self.Initialized := true;

  Self.Seed := ToStr(Self.Seed).Replace("Barely", "Barley", [rfIgnoreCase]).Before(" ") + " seed";

  Self.DebugLn("Log: " + ToStr(Self.LogType));
  Self.DebugLn("Seed: " + ToStr(Self.Seed));


  if Self.ScriptIntervalTimer.Length < 100 then
    Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
end;

function TBirdHouseInclude.GetClosestObject(evalObjects : TRSObjectArray; position : TPoint ) : TRSObject;
var
  bestDist : Int32 := 99999;
  dist : Int32 := 99999;
  i : Int8;

begin
 Result := evalObjects[0];
 dist := Distance(position, evalObjects[0].Coordinates[0]);

 for i := 0 to High(evalObjects) do
 begin
  dist := Distance(position, evalObjects[i].Coordinates[0]);

  if dist < bestDist then
  begin
    bestDist := dist;
    Result := evalObjects[i];
  end;
 end;
end;

function TBirdHouseInclude.ConfirmUptext(textToCheck : TStringArray) : Boolean;
const
  TEXT_COLOR : TCTS0Color := CTS0(14014992, 20);
var
  tpa : TPointArray;
begin
  Result := (Mainscreen.IsUpText(textToCheck))
             and (SRL.FindColors(tpa, TEXT_COLOR, MainScreen.UpTextArea) > 0);
end;

function TBirdHouseInclude.DismantleBirdhouse(out shouldSkip : Boolean) : Boolean;
var
  birdhouseATPA : T2DPointArray;
  dismantleTimeout, xpTimeout : TCountDown;
  chatTitle : string;
begin

  Self.DebugLn("Moving");
  if not WaitUntil(Self.RSW.WalkBlind(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0], 20), 150, 5000) then
    Exit;

  WaitUntil(not Minimap.IsPlayerMoving(), 50, 5000);
  Self.DebugLn("Done Moving");

  if Self.NeedClockworks then
    if not Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)) then
    begin
      Self.BuildBirdHouseItem();
    end;

  dismantleTimeout.Init(6000);

  while not dismantleTimeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      Self.DebugLn("Failed to find bird house, rotating");
      continue;
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(MainScreen.Center);

    Mouse.Move(birdHouseATPA[0].RandomValue());

    if not Self.ConfirmUptext(['nteract']) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Click(MOUSE_RIGHT);
    Self.DebugLn("Dismantling birdhouse");

    if not WaitUntil(ChooseOption.IsOpen, 100, 1200) then
      continue;

    if not ChooseOption.Select(['mpty'], MOUSE_LEFT, false, true) then
      continue;

    xpTimeout.Init(8000);
    while not xpTimeout.IsFinished() do
    begin
      if XPBar.EarnedXP() then
        break;

      chatTitle := Chat.GetChatTitle();
      if chatTitle.Contains("will lose") then
      begin
        //Close the last one because it'll break other interactions.
        if Self.BirdHousesFilled = 3 then
        begin
          Wait(Random(327, 744)); //Looks more believable
          while chatTitle.Contains("will lose") do
          begin
            chatTitle := Chat.GetChatTitle();

            if SRL.Dice(15) then
              Chat.ClickOption("leave it be", 0, [CHAT_COLOR_BLACK])
            else
              PressKey(VK_ESCAPE);

            Wait(Random(137, 352));
          end;
        end;

        shouldSkip := true;
        Exit(false);
      end;

      Wait(120);
    end;

    Result := WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 2000);
    if Result then
    begin
      Self.DebugLn("Cleared this birdhouse");
      Exit(Result);
    end;
  end;
end;

//At this point we should have a birdhouse in the inventory that we can use.
function TBirdHouseInclude.InteractWithBirdHouseSpace() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  birdHouseSpaceTPA : TPointArray;
  BirdSpaceTimeout : TCountDown;
begin
  Self.DebugLn("Interacting with space");

  BirdSpaceTimeout.Init(4000);
  while not BirdSpaceTimeout.IsFinished() do
  begin
    birdHouseSpaceTPA := Self.GetBirdHouseSpace();

    if birdHouseSpaceTPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Move(birdHouseSpaceTPA.RandomValue());

    if not Mainscreen.IsUpText(['uild', 'pace']) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Self.DebugLn("Found space");
    Mouse.Click(MOUSE_LEFT);

    if WaitUntil(not Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 200, 2300) then
    begin
      BirdSpaceTimeout.Pause();
      break;
    end;
  end;

  if BirdSpaceTimeout.IsFinished() then
    Exit(false);

  //If we click the space so we need to make sure we're not moving and we've found our current birdhouse.
  if WaitUntil(not Minimap.IsPlayerMoving()
      and ((Mainscreen.IsUpText(['eeds', 'mpty'])) or (Self.CurrentBirdHouse^.BirdhouseObject.Find(birdhouseATPA))), 75, 8000) then
    Result := true;
end;

function TBirdHouseInclude.FillBirdHouse() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  seedSlot, seedCount : Int32;
  timeout : TCountdown;
begin
  if not Inventory.FindItem(Self.Seed, seedSlot) then
  begin
    TerminateScript("No seeds!");
  end;

  seedCount := Inventory.CountItemStack(Self.Seed);

  while not Inventory.IsSlotSelected(seedSlot) do
  begin
    Inventory.SetSelectedSlot(-1);
    Inventory.SetSelectedSlot(seedSlot);
    Wait(100);
  end;

  timeOut.Init(6500);
  Self.DebugLn("Attempting to fill birdhouse");
  while not timeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(Mainscreen.Center);
    Mouse.Move(birdhouseATPA[0].RandomValue());

    if Self.ConfirmUptext(['mpty']) then
    begin
      timeout.Pause();
      Mouse.Click(MOUSE_LEFT);
      break;
    end;

    Antiban.RandomRotate();
    Wait(Random(110, 210));
  end;

  if timeout.IsFinished() then
  begin
    Self.DebugLn("Timed out on filling, skipping this birdhouse");
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Exit;
  end;

  Result := WaitUntil(seedCount > Inventory.CountItemStack(Self.Seed), 100, 6000);
end;

function TBirdHouseInclude.BuildBirdHouseItem() : Boolean;
var
  birdHouseItem : TRSItem := Self.GetBirdhouseItem(Self.LogType);

begin
  if not Inventory.ContainsItem('Clockwork')
  and not Inventory.ContainsItem(birdHouseItem) then
  begin
    Self.DebugLn("No clockwork or birdhouse in inventory, we can't continue!");
    Self.DebugLn("Ending run!");
    Self.BirdHousesFilled := 4;
    Exit(false);
  end;

  Result := Inventory.ContainsItem(birdHouseItem);

  if not Result then
  begin
    Self.DebugLn("No birdhouse in inventory, making one");

    if not Inventory.Use('Chisel', Self.GetLogString(Self.LogType)) then
    begin
      Self.DebugLn("Failed to use chisel");
      Exit;
    end;

    if WaitUntil(Make.IsOpen(), 100, 1200) then
    begin
      if not Make.Select(ToStr(birdHouseItem), Make.QUANTITY_ALL, Antiban.BioDice()) then
      begin
        Self.DebugLn("Failed to make birdHouse");
        Exit;
      end;
    end;

    if not WaitUntil(Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 100, 3000) then
    begin
      Self.DebugLn("Inventory has no birdHouse");
      Exit;
    end;

    Result := true;
  end;
end;

function TBirdHouseInclude.HandleBirdHouse() : Boolean;
var
  shouldSkip : Boolean;
begin
  //There's already a birdhouse there and should be ready for dismantling
  //Find our current birdhouse and interact with it.
  //Dismantle and return once there's a space.

  if Self.DismantleBirdhouse(shouldSkip) then
  begin
    Self.DebugLn("Dismantled our current birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 4000);
    if not Self.NeedClockworks
    and WaitUntil(Inventory.ContainsItem("Clockwork"), 10, 2000) then
    begin
      Wait(Random(150, 241)); //Prevent 1 ticking the build and the space click
      if not Self.BuildBirdHouseItem() then
        Exit;
    end;
  end;

  if shouldSkip then
  begin
    Self.DebugLn("Too early for this birdhouse, skipping.");
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Exit;
  end;

  Wait(Random(313, 523));

  //Check for a space and build a birdhouse there.
  if Self.InteractWithBirdHouseSpace() then
  begin
    Self.DebugLn("Built new birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
  end;

  Wait(Random(241, 456));

  if Self.FillBirdHouse() then
  begin
    Self.DebugLn("Filled birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Result := true;
  end;
end;

function TBirdHouseInclude.GetBirdhouseFillCount() : Int32;
var
  i : Int32;
begin
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      Inc(Result);
  end;
end;

procedure TBirdHouseInclude.Reset()
var
  i : Int32;
begin
  Self.MushIndex := 0;
  Self.BirdHousesFilled := 0;
  Self.CurrentBirdHouse := nil;
  Self.ShouldTeleport := true;

  for i := 0 to High(Self.birdHouses) do
    Self.birdHouses[i].IsFilled := false;
end;

function TBirdHouseInclude.GetState() : EScriptState;
var
  myPos : TPoint := Self.RSW.GetMyPos();
  bestBHIndex : Int32 := -1;
begin
  if Self.HasRunFinished then
    Exit(EScriptState.DO_NOTHING);

  if (Self.BirdHousesFilled >= 4) then
  begin
    Self.DebugLn("Run finished");
    Inc(Self.RunsCompleted);
    Self.TotalXPEarned += XPBar.Read() - Self.RunStartXp;
    Self.NestsLooted += Inventory.CountItem('Bird nest');

    if WaitUntil(Chat.HasContinue(), 150, 1400) then
      Chat.ClickContinue(true);

    Self.HasRunFinished := true;
    Self.Reset();
    Exit(EScriptState.DO_NOTHING);
  end;

  if not Self.HasTools() then
  begin
    Self.HasRunFinished := true;
    Self.Reset();
    Self.DebugLn("Ending run: Missing some tools");
    Exit(EScriptState.DO_NOTHING);
  end;

  if (Self.GetNearestUnfilledBirdHouse(myPos, bestBHIndex))
  and (bestBHIndex > -1 ) then
  begin
    Self.CurrentBirdHouse := @Self.birdHouses[bestBHIndex];

    if myPos.DistanceTo(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0]) < 100 then
    begin
      Self.ShouldTeleport := false;
      Exit(EScriptState.INTERACT_BIRDHOUSES);
    end;

    Self.ShouldTeleport := true;
  end;

  if Self.MushIndex = High(Self.Mushrooms) then
    Exit(EScriptState.NAVIGATING);

  if Self.ShouldTeleport then
  begin
    if Self.MushIndex < High(Self.Mushrooms) then
    begin
      Self.CurrentBirdHouse := nil;

      if MushTree.IsOpen() then
        Exit(EScriptState.USE_MUSHROOM);

      Exit(EScriptState.CLICK_MUSHROOM);
    end;
  end;
end;

function TBirdHouseInclude.WalkToMushroom(index : Int32 = -1) : Boolean;
var
  indexToUse : Int32;
begin
  WaitEx(2500, 500);

  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  if not Self.Mushrooms[indexToUse].Mushroom.WalkClick() then
    Self.Debugln("Failed to get to mushroom")
  else
    Result := WaitUntil(Mushtree.IsOpen(), 300, 10000);
end;

function TBirdHouseInclude.HandleMushroomTeleport(index : Int32 = -1) : Boolean;
var
  mushroomBox : TBox;
  indexToUse : Int32;
begin
  if not MushTree.IsOpen() then
    Exit();

  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  Mushtree.Click(Self.Mushrooms[indexToUse].GetMushButton());

  mushroomBox := Box(Self.Mushrooms[indexToUse].Mushroom.Coordinates[0], 100, 100);

  if WaitUntil(not mushroomBox.Contains(Self.RSW.GetMyPos()), 400, 6000) then
  begin
    Self.DebugLn("Successfully teleported to mushroom");
    Result := true;
    if index = -1 then
      Self.MushIndex := Min(MushIndex + 1, High(Self.Mushrooms));

    Self.DebugLn("Mush index now: " + ToStr(Self.MushIndex));
    //Basically waiting for screen to fade in.
    Wait(Random(1400, 2200));
  end;
end;

function TBirdHouseInclude.HandleCave(): Boolean;
var
  tpa: TPointArray;
  ropeClicked: Boolean;
begin
  if SRL.FindColors(tpa, CTS2(4474118, 3, 0.30, 5.83), Mainscreen.Bounds) < 1000 then
    Exit(true);

  for 0 to 5 do
  begin
    if SRL.FindColors(tpa, CTS2(6717077, 11, 0.09, 0.47), Mainscreen.Bounds) < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    tpa := tpa.Cluster(5).Biggest();

    Mouse.Move(tpa);
    if not Mainscreen.IsUpText(['up', 'xit' ]) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Click(MOUSE_LEFT);
    if ropeClicked := Mainscreen.DidRedClick(300) then
      break;
  end;

  if not ropeClicked then
    Exit(false);

  Result := WaitUntil(SRL.CountColor(CTS2(4474118, 3, 0.30, 5.83), Mainscreen.Bounds) < 1000, 750, 10000);
end;

function TBirdHouseInclude.HandleNavigating() : Boolean;
begin
  Self.RSW.ScreenWalk := false;
  Self.RSW.AdaptiveWalk := false;

  try
    if not Self.RSW.WebWalk(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0], 10) then
    begin
      Self.DebugLn("We may have entered the cave. Trying to handle it...");
      if not HandleCave() then
      begin
        Self.DebugLn("Couldn't recover. Terminating.");
        TerminateScript();
      end
      else
        Self.DebugLn("Recovered!");
    end;
  except
    begin
      Self.DebugLn("Web walker caused an exception, may have entered the cave. Trying to handle it...");
      if not HandleCave() then
      begin
        Self.DebugLn("Couldn't recover. Terminating.");
        TerminateScript();
      end
      else
        Self.DebugLn("Recovered!");
    end;
  end;

  Self.RSW.ScreenWalk := true;
  Self.RSW.AdaptiveWalk := true;
  Result := true;
end;

function TBirdHouseInclude.GetLogForHunterLevel(level : Int32) : ERSLogType;
var
  craftLevel : Int32 := Stats.GetLevel(ERSSkill.CRAFTING, false);

begin
  Self.DebugLn("Detected hunter level: " + ToStr(level) + " detected crafting level: " + ToStr(craftLevel));
  if (level >= 89) and (craftLevel >= 90) then
    Result := ERSLogType.REDWOOD_LOGS
  else if (level >= 74) and (craftLevel >= 75) then
    Result := ERSLogType.MAGIC_LOGS
  else if (level >= 59) and (craftLevel >= 60) then
    Result := ERSLogType.YEW_LOGS
  else if (level >= 49) and (craftLevel >= 50) then
    Result := ERSLogType.MAHOGANY_LOGS
  else if (level >= 44) and (craftLevel >= 45) then
    Result := ERSLogType.MAPLE_LOGS
  else if (level >= 34) and (craftLevel >= 35) then
    Result := ERSLogType.TEAK_LOGS
  else if (level >= 24) and (craftLevel >= 25) then
    Result := ERSLogType.WILLOW_LOGS
  else if (level >= 14) and (craftLevel >= 15) then
    Result := ERSLogType.OAK_LOGS
  else
    Result := ERSLogType.REGULAR_LOGS;
end;

function TRSBank.FindAny(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if Self.FindItem(tempItem, tempBox) then
      Exit(true);
  end;
end;

function TBirdHouseInclude.GetNextBestLogInBank(currLog : ERSLogType) : ERSLogType;
var
  i : Int32;
  tempBox : TBox;
  foundBankItem : TRSBankItem;
begin
  if not Bank.IsOpen() then
    Exit(Self.LogType);

  for i := Ord(currLog) downto 0 do
  begin
    foundBankItem.Item := Self.GetLogString(ERSLogType(i));

    if Bank.FindItem(foundBankItem, tempBox) then
      Exit(ERSLogType(i));
  end;

  Self.DebugLn("Couldn't find any other logs");
  TerminateScript("Out of logs");
end;

function TBirdHouseInclude.WalkToIslandBank() : Boolean;
begin
  if Self.AlwaysUseBestLog then
    Self.SuggestedLogType := Self.GetLogForHunterLevel(Stats.GetLevel(ERSSkill.HUNTER, false));

  Result := Bank.WalkOpen(RSObjects.BankChestFossilIsland);
end;

//Function responsible for getting to a bank
//Probably switching gear
//Withdrawing the needed things
//Should return if it was successful
function TBirdHouseInclude.OnStart() : Boolean;
begin
  Exit(true);
end;

procedure TBirdHouseInclude.OnComplete();
begin
  Exit;
end;

function TBirdHouseInclude.HasAllItemsForRun() : Boolean;
var
  tools: TRSBankItemArray;
  i: Int32;
  itemStr: string;
begin
  tools := Self.GetWithdrawList();

  for i := 0 to High(tools) do
  begin
    itemStr := ToStr(tools[i].Item);
    if itemStr.Contains("seed") then
    begin
      if Inventory.CountItemStack(tools[i].Item) < 40 then
      begin
        Self.DebugLn("Cannot do run, missing some seeds");
        Exit(false);
      end;
    end
    else
    begin
      if Inventory.CountItem(tools[i].Item) < tools[i].Quantity then
      begin
        Self.DebugLn("Cannot do run, not enough of item: " + itemStr);
        Exit(false);
      end;
    end;
  end;

  Result := true;
end;

function TBirdHouseInclude.TeleportToIsland() : Boolean;
var
  transporter: TUniversalTransport;
begin
  Result := transporter.Run(RSTEleports.FOSSIL_ISLAND);
  if not Result then
    Self.DebugLn("Could not teleport");
end;

//These 3 functions together look dumb
//But it's actually so authors can do something like
//procedure TBirdHouseInclude.PrintReport() override;
//PrintMainScriptReport()
//inherited;
//As a way to append it.

procedure TBirdHouseInclude.BirdhouseRun();
var
  CachedWalker: PRSWalker;
begin
  CachedWalker := ScriptWalker;

  if not Self.Initialized then
    Self.Init();

  Self.DebugLn("Calling OnStart Method");

  if not Self.OnStart() then
    Exit;

  if (not GetHouseOnHillRegion().Contains(ScriptWalker^.GetMyPos()))
    and not (Self.TeleportToIsland()) then
    Exit;

  ScriptWalker := @Self.RSW;
  Self.RunStartXp := XPBar.Read();

  while not Self.HasRunFinished do
  begin
    //Re-log in during run
    if not RSClient.IsLoggedIn() then
    begin
      if not Login.LoginPlayer() then
        TerminateScript("Could not log in player");
    end;

    Self.State := Self.GetState();

    if Self.State <> EScriptState.DO_NOTHING then
      Self.DebugLn("SciptState: " + ToStr(Self.State));

    case Self.State of
      EScriptState.BUILD_BIRDHOUSE : Self.BuildBirdHouseItem();
      EScriptState.INTERACT_BIRDHOUSES : Self.HandleBirdHouse();
      EScriptState.CLICK_MUSHROOM : Self.WalkToMushroom();
      EScriptState.USE_MUSHROOM : Self.HandleMushroomTeleport();
      EScriptState.TELEPORTING : ;
      EScriptState.DO_NOTHING : ;
      EScriptState.NAVIGATING : Self.HandleNavigating();
    end;
  end;

  //Responsible for getting them back to their initial activity
  Self.DebugLn("Calling OnComplete Method");
  Self.OnComplete();
  Self.HasRunFinished := false;
  ScriptWalker := CachedWalker;
end;

function TBirdHouseInclude.CanDoBirdHouseRun() : Boolean;
begin
  if Self.IsDisabled then
    Exit(false);

  if not Self.ScriptIntervalTimer.IsFinished() then
  begin
    if (Self.NextRunSpewTimer.TimeRemaining = 0)
        or (Self.NextRunSpewTimer.IsFinished()) then
    begin
      NextRunSpewTimer.Init(5 * ONE_MINUTE);
      Self.DebugLn('Next birdhouse run in ' + SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Short));
    end;

    Exit(false);
  end;

  Result := true;
end;

procedure TBirdHouseInclude.DoBirdHouseRun();
begin
  Self.BirdhouseRun();

  if(Self.TaskInterval < (50 * ONE_MINUTE)) then
    Self.TaskInterval := 50 * ONE_MINUTE;

  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
end;

function TBirdHouseInclude.WithdrawNextRun() : Boolean;
var
  itemList : TRSBankItemArray;
  i, itemNumNeeded : Int32;
  itemName : string;
  nextBestLog : ERSLogType;
  transporter: TUniversalTransport;
begin
  if not Bank.IsOpen() then
    Exit;

  if Self.AlwaysUseBestLog
  and not Self.TerminateOnNoLogs
  and (Self.LogType <> Self.SuggestedLogType) then
  begin
    if not Bank.FindAll([Self.GetLogString(Self.LogType), Self.GetLogString(Self.SuggestedLogType)]) then
    begin
      Self.DebugLn("Bank doesn't have our best choice or current choice, finding another");
      nextBestLog := Self.GetNextBestLogInBank(Self.LogType);
      Self.DebugLn("Next best log is: " + ToStr(nextBestLog) + " changing our current log: " + ToStr(Self.LogType) + " to this one");
      Self.LogType := nextBestLog;
    end
    else if Self.LogType <> Self.SuggestedLogType then
    begin
      Self.DebugLn("Updated current log type: " + ToStr(Self.LogType) + " to best type: " + ToStr(Self.SuggestedLogType));
      Self.LogType := Self.SuggestedLogType;
    end;
  end;

  itemList := Self.GetWithdrawList();

  for i := 0 to High(itemList) do
  begin
    itemName := ToStr(itemList[i].Item);

    if not itemName.Contains('seed') then
      itemNumNeeded := itemList[i].Quantity - Inventory.CountItem(itemList[i].Item)
    else
      itemNumNeeded := itemList[i].Quantity - Max(0, Inventory.CountItemStack(itemList[i].Item));

    if itemNumNeeded < 1 then
    begin
      Self.DebugLn("Skipping withdraw for item: " + ToStr(itemList[i].Item));
      continue;
    end;

    itemList[i].Quantity := itemNumNeeded;
    if not Bank.WithdrawItem(itemList[i], false) then
    begin
      Self.DebugLn("Bank is missing: " + ToStr(itemList[i].Item));
      Exit(false);
    end;

    if not WaitUntil(Inventory.ContainsItem(itemList[i].Item), 100, 2000) then
    begin
      Self.DebugLn("Could not withdraw item: " + ToStr(itemList[i].Item));
      Exit(false);
    end;
  end;

  if not transporter.withdrawTeleportItem(RSTeleports.FOSSIL_ISLAND) then
  begin
    Self.DebugLn("Could not get pendant");
    Exit(false);
  end;

  Result := true;
end;

//If you don't use the GUI's TScriptForm.CreateBirdhouseRunSettings
//Use this to set the values directly.
procedure TBirdHouseInclude.Setup(log : ERSLogType; seedItem : TRSItem; useBestLog : Boolean = false; interval : UInt32 = (50 * ONE_MINUTE); needClockwork : Boolean = true);
begin
  with Self do
  begin
    LogType := log;
    Seed := seedItem;
    AlwaysUseBestLog := useBestLog;
    NeedClockworks := needClockwork;
    TaskInterval := interval;
  end;

  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
end;

//Weird name because it'll likely get used as a regular formutil at some point
procedure TComponent.CJTextField({$H-}sender: TObject;{$H+} var key: char);
begin
  if not (key in ['A'..'Z', 'a'..'z', #8]) then
    key := #0;
end;

procedure TScriptForm.OnCheckBoxChanged(sender: TObject);
var
  checkBox : TCheckBox;
  isChecked : Boolean;
begin
  checkBox := sender;
  isChecked := checkBox.IsChecked();

  case checkBox.getName() of
    'bh_extraclockworkcb_checkbox' : BirdHouseRunner.NeedClockworks := isChecked;
    'bh_bestlogcb_checkbox': BirdHouseRunner.AlwaysUseBestLog := isChecked;

    'farm_hosidiusherb_checkbox': FarmRunner.HosidiusHerb := isChecked;
    'farm_hosidiusflower_checkbox': FarmRunner.HosidiusFlower := isChecked;
    'farm_catherbyherb_checkbox': FarmRunner.CatherbyHerb := isChecked;
    'farm_catherbyflower_checkbox': FarmRunner.CatherbyFlower := isChecked;
    'farm_faladorherb_checkbox': FarmRunner.FaladorHerb := isChecked;
    'farm_faladorflower_checkbox': FarmRunner.FaladorFlower := isChecked;
    'farm_ardougneherb_checkbox': FarmRunner.ArdougneHerb := isChecked;
    'farm_ardougneflower_checkbox': FarmRunner.ArdougneFlower := isChecked;
    'farm_magicsecateurs_checkbox': FarmRunner.MSecs := isChecked;
    'farm_barbariandibber_checkbox': FarmRunner.BDibber := isChecked;
    'farm_startwithrun_checkbox': FarmRunner.StartWithRun := isChecked;
  else
    WriteLn('A checkbox is configured wrong!');
  end;
end;

function TScriptForm.CreateBirdhouseRunSettings(): TTabSheet;
  type TScriptForm = TScriptForm;

  procedure TScriptForm._SeedChanged(sender: TObject);
  var
    seed : TEdit;
  begin
    seed := sender;
    BirdHouseRunner.Seed := seed.getText();
  end;

  procedure TScriptForm._LogTypeChanged(sender: TObject);
  var
    combobox: TComboBox;
  begin
    combobox := sender;
    BirdHouseRunner.LogType := ERSLogType(comboBox.getItemIndex());
  end;

  procedure TScriptForm._BHIncludeOnRadioChanged(sender: TObject);
  var
    radio : TRadioButton;
  begin
    radio := sender;
    case radio.getName() of
      'bh_nowradio' : BirdHouseRunner.TaskInterval := 0;
      'bh_laterradio' : BirdHouseRunner.TaskInterval := BirdHouseRunner.TaskInterval := 50 * ONE_MINUTE;
    end;
  end;

const
  H_SPACING : Int32 := 50;
var
  logTypeCombo : TLabeledCombobox;
  nowRadio, laterRadio: TRadioButton;
  intervalLabel : TLabel;
  seedEdit  : TLabeledEdit;
  fullWidth, w, space, y: Int32;

begin
  Self.AddTab('Birdhouse Settings');
  Result := Self.Tabs[High(Self.Tabs)];

  fullWidth := Self.Size.X;
  space := Floor(fullWidth * 0.1);
  w := fullWidth - (space * 2);
  y := Floor(Self.Size.Y/6);

  with logTypeCombo do
  begin
    Create(Result);
    SetCaption('Log type to use:');
    SetStyle(csDropDownList);
    AddItemArray(['Regular', 'Oak', 'Willow', 'Teak',
                  'Maple', 'Mahogany', 'Yew', 'Magic tree', 'Redwood']);
    SetLeft(TControl.AdjustToDPI(H_SPACING));
    SetTop(TControl.AdjustToDPI(15));
    BirdHouseRunner.LogType := BHIncludeGUILogType;
    SetItemIndex(Ord(BirdHouseRunner.LogType));
    Combobox.SetOnChange(@Self._LogTypeChanged);
  end;

  with seedEdit do
  begin
    Create(Result);
    SetTop(logTypeCOmbo.GetTop());
    SetLeft(logTypeCombo.GetRight() + TControl.AdjustToDPI(H_SPACING));
    SetWidth(250);
    SetCaption("Seed: just the name like potato or cabbage");
    SetTooltip("Just the name of the seed don't include the word seed!");
    SetName('bh_seed');
    SetMaxLength(30);
    BirdHouseRunner.Seed := ToStr(BHIncludeGUISeed).Replace("Barely", "Barley", [rfIgnoreCase]).Before(" ");
    Edit.setOnChange(@Self._SeedChanged);
    Edit.setOnKeyPress(@Edit.CJTextField);
    SetText(ToStr(BirdHouseRunner.Seed));
  end;

  with intervalLabel do
  begin
    Create(Result);
    SetCaption("When should the next run start?"
               + #13#10 + "Runs afterwards will continue every 50 - 60 minutes automatically.");
    SetLeft(logTypeCombo.GetLeft());
    SetTop(logTypeCombo.GetTop() + TControl.AdjustToDPI(60));
    SetFontSize(9);
  end;

  with nowRadio do
  begin
    Create(Result);
    SetName("bh_nowradio");
    SetLeft(intervalLabel.GetLeft());
    SetTop(intervalLabel.GetTop() + TControl.AdjustToDPI(33));
    SetCaption("Do a run now");
    SetOnClick(@Self._BHIncludeOnRadioChanged);
    SetFontSize(9);
  end;

  with laterRadio do
  begin
    Create(Result);
    SetName("bh_laterradio");
    SetCaption("Do a run later (in about 50 - 60 minutes)");
    SetLeft(nowRadio.getLeft());
    SetTop(nowRadio.getTop() + TControl.AdjustToDPI(25));
    SetOnClick(@Self._BHIncludeOnRadioChanged);
    SetFontSize(9);
  end;

  BirdHouseRunner.TaskInterval := BHIncludeGUIRunIntervalMinutes;

  if BHIncludeGUIRunIntervalMinutes > 0 then
  begin
    laterRadio.setState(TCheckBoxState.cbChecked);
    nowRadio.setState(TCheckBoxState.cbUnchecked);
    BirdHouseRunner.TaskInterval := 50 * ONE_MINUTE;
  end
  else
  begin
    laterRadio.setState(TCheckBoxState.cbUnchecked);
    nowRadio.setState(TCheckBoxState.cbChecked);
    BirdHouseRunner.TaskInterval := 0;
  end;
end;

begin
  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6646, 2594],
    [6653, 2583],
    EPatchType.HERB,
    [6286, 2351, 6910, 2850],
    'Catherby herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6626, 2594],
    [6653, 2583],
    EPatchType.FLOWER,
    [6286, 2351, 6910, 2850],
    'Catherby flower'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6075, 2949],
    [6080, 2923],
    EPatchType.HERB,
    [5855, 2792, 6286, 3070],
    'Ardy herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [6058, 2949],
    [6080, 2923],
    EPatchType.FLOWER,
    [5855, 2792, 6286, 3070],
    'Ardy flower'
  ];

  PatchData += [
    CTS2(6127499, 6, 0.10, 0.71),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [2346, 2258],
    [2357, 2252],
    EPatchType.HERB,
    [2150, 2050, 2600, 2600],
    'Hosidious herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [2331, 2242],
    [2357, 2252],
    EPatchType.FLOWER,
    [2150, 2050, 2600, 2600],
    'Hosidious flower'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [7626, 3202],
    [7604, 3228],
    EPatchType.HERB,
    [7500, 3100, 7700, 3450],
    'Fally herb'
  ];

  PatchData += [
    CTS2(5927804, 9, 0.05, 0.11),
    CTS2(2970201, 11, 0.05, 0.25),
    CTS2(3108159, 13, 0.08, 1.39),
    [7610, 3218],
    [7604, 3228],
    EPatchType.FLOWER,
    [7500, 3100, 7700, 3450],
    'Fally flower'
  ];
end;

procedure TRSItemArray.Add(Items: TRSItemArray);
var
  Item: TRSItem;
begin
  for Item in Items do
    Self += Item;
end;

function TFarmRunner.GetNextTime(): Int32;
begin
  Exit(Random(86*ONE_MINUTE, 97*ONE_MINUTE));
end;

function TRSInventory.Count(): Int32; override;
var
  Slot: Int32;
begin
  if not Self.Open() then
    Exit();

  for Slot := 0 to 27 do
    if Self.IsSlotUsed(Slot) then
      Inc(Result)
end;

function TScriptForm.CreateFarmRunSettings(): TTabSheet;
  type TScriptForm = TScriptForm;

  procedure TScriptForm._FarmSeedChanged(sender: TObject);
  var
    seed : TEdit;
  begin
    seed := sender;
    FarmRunner.HerbSeed := seed.getText();
  end;

  procedure TScriptForm._CompostTypeChanged(sender: TObject);
  var
    combobox: TComboBox;
  begin
    combobox := sender;
    FarmRunner.CompostMethod := ECompostMethod(comboBox.getItemIndex());
  end;

var
  Info: TLabel;
  MagicSecateursCheckbox, CatherbyHerbCheckbox, HosidiusHerbCheckbox,
  CatherbyFlowerCheckbox, HosidiusFlowerCheckbox, FaladorHerbCheckbox,
  FaladorFlowerCheckbox, ArdougneHerbCheckbox, ArdougneFlowerCheckbox,
  BarbarianDibberCheckbox, FarmRunNowCheckbox: TLabeledCheckBox;
  CompostInput: TLabeledCombobox;
  SeedInput: TLabeledEdit;
begin
  Self.AddTab('Farm Run Settings');
  Result := Self.GetTab('Farm Run Settings');

  Result.SetToolTip('');

  with Info do
  begin
    Create(Result);
    SetLeft(30);
    SetTop(30);
    SetHeight(80);
    SetWidth(600);
    SetFontSize(10);
    SetToolTip('');
    SetCaption('If you have problems with the settings, check the script page for instructions.');
  end;

  with HosidiusHerbCheckbox do
  begin
    Create(Result);
    SetName('farm_hosidiusherb');
    SetCaption('Hosidius Herb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(130));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with HosidiusFlowerCheckbox do
  begin
    Create(Result);
    SetName('farm_hosidiusflower');
    SetCaption('Hosidius Limpwurt');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(110));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with CatherbyHerbCheckbox do
  begin
    Create(Result);
    SetCaption('Catherby Herb');
    SetName('farm_catherbyherb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(90));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with CatherbyFlowerCheckbox do
  begin
    Create(Result);
    SetCaption('Catherby Limpwurt');
    SetName('farm_catherbyflower');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(70));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with FaladorHerbCheckbox do
  begin
    Create(Result);
    SetCaption('Falador Herb');
    SetName('farm_faladorherb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(150));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with FaladorFlowerCheckbox do
  begin
    Create(Result);
    SetCaption('Falador Limpwurt');
    SetName('farm_faladorflower');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(170));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with ArdougneHerbCheckbox do
  begin
    Create(Result);
    SetCaption('Ardougne Herb');
    SetName('farm_ardougneherb');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(190));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with ArdougneFlowerCheckbox do
  begin
    Create(Result);
    SetCaption('Ardougne Limpwurt');
    SetName('farm_ardougneflower');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(380));
    SetTop(TControl.AdjustToDPI(210));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with MagicSecateursCheckbox do
  begin
    Create(Result);
    SetName('farm_magicsecateurs');
    SetCaption('Use Magic Secateurs');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(160));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with BarbarianDibberCheckbox do
  begin
    Create(Result);
    SetName('farm_barbariandibber');
    SetCaption('Barbarian Seed Dibber unlocked');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(185));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with FarmRunNowCheckbox do
  begin
    Create(Result);
    SetCaption('Start with a farm run');
    SetName('farm_startwithrun');
    SetTooltip('');
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(210));
    CheckBox.setOnChange(@Self.OnCheckBoxChanged);
  end;

  with CompostInput do
  begin
    Create(Result);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(70));
    AddItemArray(["Ultracompost", "Bottomless Compost"]);
    SetCaption('Compost:');
    Combobox.SetOnChange(@Self._CompostTypeChanged);
  end;

  with SeedInput do
  begin
    Create(Result);
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(TControl.AdjustToDPI(110));
    SetCaption('Herb Seed:');
    SetText('Toadflax seed');
    FarmRunner.HerbSeed := 'Toadflax seed';
    Edit.setOnChange(@Self._FarmSeedChanged);
    Edit.setOnKeyPress(@Edit.CJTextField);
  end;
end;

procedure TFarmRunner.AddPatch(Patch: EFarmPatch; Travel: ETravelMethod; Seed: TRSItem);
var
  EmptyUpText: TStringArray := ['Herb', 'Flower', 'Bush', 'Allotment', 'Cactus', 'Seaweed patch'];
  HarvestUpText: TStringArray := ['ick', 'ick', 'ick', 'arves', 'ick', 'ick'];
  Data: TPatchData := PatchData[Patch];
  TPA: TPointArray;
  SearchBox: TBox;
  Empty: String := EmptyUpText[Data.PatchType];
  Planted: String := ToStr(Seed).Before(' ');
  Harvest: String := HarvestUpText[Data.PatchType];
begin
  if Data.PatchType = EPatchType.HERB then
    Planted := 'Herb';

  Self.Patches += [Empty, Planted, Harvest, Travel, Data, TPA, SearchBox, Seed];
end;

function TFarmRunner.CanDoFarmRun(): Boolean;
begin
  Result := Self.ReadyTimer.IsFinished();
end;

function TFarmPatch.Find(Retry: Boolean = True): Boolean;
var
  Attempts: Int32;

  function F(): Boolean
  var
    FilterPt: TPoint := ScriptWalker^.GetTileMS(Self.Data.Coords).Mean();
    BorderTPA, SearchFiltered: TPointArray;
    BorderATPA: T2DPointArray;
    SearchPt: TPoint;
    i: Int32;
  begin
    if not (FilterPt in Mainscreen.Bounds) then
      Exit(False);

    if SRL.FindColors(BorderTPA, Self.Data.BorderColor, MainScreen.Bounds) = 0 then
      Exit(False);

    BorderATPA := BorderTPA.Cluster(Mainscreen.NormalizeDistance(32));
    for i := 0 to High(borderATPA) do
    begin
      Self.TPA := BorderATPA[i].ConvexHull.Connect();

      if SRL.PointInPoly(FilterPt, Self.TPA) then
      begin
        Self.TPA := Self.TPA.SortFrom(MainScreen.Center);
        SearchFiltered := Self.TPA.FilterDist(0, MainScreen.NormalizeDistance(140), Self.TPA[0].X, Self.TPA[0].Y);
        SearchFiltered := SearchFiltered.SortFrom(MainScreen.Center);
        SearchPt := SearchFiltered.Mean();
        Self.SearchBox := Box(SearchPt, MainScreen.NormalizeDistance(14), MainScreen.NormalizeDistance(14));
        Self.SearchBox.LimitTo(MainScreen.Bounds);
        RSClient.Image.Clear();

        //RSClient.Image.DrawRect(Self.TPA.MinAreaRect, CHAT_COLOR_LIGHT_PURPLE);
        //RSClient.Image.DrawBox(Self.SearchBox, CHAT_COLOR_MAROON);

        Exit(True);
      end;
    end;
    Self.SearchBox := [0, 0, 0, 0];
    Self.TPA := [];
    Result := False;
  end;

begin
  if not Retry then
    Exit(F());

  Result := False;
  for Attempts := 0 to 3 do
  begin
    if F() then
      Exit(True);

    try
    case attempts of
      0:
      begin
        if not ScriptWalker^.MakePointVisible(Self.Data.Coords) then
        begin
          ScriptWalker^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
          ScriptWalker^.MakePointVisible(Self.Data.Coords);
        end
      end;

      1: Antiban.RandomRotate();
      2:
      begin
        ScriptWalker^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
        ScriptWalker^.MakePointVisible(Self.Data.Coords);
      end;
      3:
      begin
        Exit();
      end;
    end;
    except
      Exit();
    end;
  end;
end;

function TFarmPatch.IsDead(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(CTS2(6050153, 7, 2.73, 0.61), Self.SearchBox);
  Result := ColorCount > MainScreen.NormalizeDistance(24);
end;

function TFarmPatch.IsDiseased(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(CTS2(1272942, 14, 0.03, 2.31), Self.SearchBox);
  Result := ColorCount > MainScreen.NormalizeDistance(40);
end;

function TFarmPatch.IsEmpty(): Boolean;
var
  ColorCount: Int32;
begin
  ColorCount := SRL.CountColor(Self.Data.SoilColor, Self.SearchBox);
  Result := ColorCount = Self.SearchBox.Area;
end;

function TFarmPatch.FindLeprechaun(out Point: TPoint; Retry: Boolean = True): Boolean;
var
  Attempts: Int32;

  function F(): Boolean;
  var
    SearchTPA, LeprechaunTPA: TPointArray;
    Cuboids: TCuboidExArray;
    FindBox: TBox;
  begin
    Cuboids := ScriptWalker^.GetCuboidArrayMS([Self.Data.LeprechaunCoords], [1.5, 1.5, 8], [0, 0]);

    if Length(Cuboids) = 0 then
      Exit();

    FindBox := Cuboids[0].Bounds();
    FindBox.LimitTo(MainScreen.Bounds);

    if SRL.FindColors(SearchTPA, Self.Data.LeprechaunColor, FindBox) = 0 then
      Exit();

    LeprechaunTPA := Cuboids[0].Filter(SearchTPA);

    if LeprechaunTPA.Len = 0 then
      Exit();

    Point := LeprechaunTPA.Mean();
    Result := True;
  end;

begin
  if not Retry then
    Exit(F());

  for Attempts := 0 to 3 do
  begin
    if F() then
      Exit(True);

    case Attempts of
      0, 2:
      begin
        if not ScriptWalker^.MakePointVisible(Self.Data.LeprechaunCoords) then
        begin
          ScriptWalker^.WebWalk([Self.Data.LeprechaunCoords.X + 4, Self.Data.LeprechaunCoords.Y + 4]);
          ScriptWalker^.MakePointVisible(Self.Data.LeprechaunCoords);
        end
      end;
      1: Antiban.RandomRotate();
      3: WriteLn('Failed to find leprechaun.');
    end;
  end;
end;

function TFarmPatch.GetState(): EPatchState;
label
  Inspect;
var
  Message: String;
  i: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit(EPatchState.FAILED);

  RSInterface.Close();
  Inventory.SetSelectedSlot(-1);

  if Self.Complete then
    Exit(EPatchState.COMPLETE);
  if Self.Skip then
    Exit(EPatchState.SKIP);

  if Minimap.InPOH then
    Exit(EPatchState.TELEPORT_TO);

  if not (ScriptWalker^.GetMyPos in Self.Data.MapCoords) then
    Exit(EPatchState.TELEPORT_TO);

  if not Self.Find then
    Exit(EPatchState.FAILED);

  if Self.IsEmpty then
    Exit(EPatchState.PLANT);

  if Self.IsDiseased then
    Exit(EPatchState.DISEASED);

  if Self.IsDead then
    Exit(EPatchState.DEAD);

  if Inventory.IsFull then
    Exit(EPatchState.NOTE_ITEMS);

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.SearchBox))
  else
    Mouse.Move(Self.SearchBox);

  if Mainscreen.IsUpText(Self.HarvestUpText) then
    Exit(EPatchState.HARVEST);

  if Mainscreen.IsUpText('Dead') then
    Exit(EPatchState.DEAD);

  if Mainscreen.IsUpText('Cure') then
    Exit(EPatchState.DISEASED);

  if MainScreen.IsUpText('Inspect') then
  begin
    Mouse.Click(MOUSE_LEFT);
    goto Inspect;
  end;

  Mouse.Click(MOUSE_RIGHT);

  if ChooseOption.HasOption('Dead', True, False) then
    Exit(EPatchState.DEAD);

  if ChooseOption.HasOption(Self.HarvestUpText, True, False) then
    Exit(EPatchState.HARVEST);

  if ChooseOption.HasOption('Cure', True, False) then
    Exit(EPatchState.DISEASED);

  if ChooseOption.Select('Inspect') then
      goto inspect
  else
    Exit(EPatchState.FAILED);

  Inspect:
  if not WaitUntil(Chat.FindMessage('The soil'), 15, 10000) then
    Exit(EPatchState.FAILED);

  for i := 5 to 8 do
    Message += Chat.GetMessage(i);

  if Message.Contains('is empty') then
    Exit(EPatchState.PLANT);

  if Message.Contains('not been') then
    Exit(EpatchState.COMPOST);

  if Message.Contains('fully grown') then
    Exit(EPatchState.HARVEST);

  if Message.ContainsAll(['has been', 'growing in it']) then
    Exit(EPatchState.COMPLETE);

  if Message.Contains('dead') then
    Exit(EPatchState.DEAD);

  if Message.Contains('diseas') then
    Exit(EPatchState.DISEASED);

  Exit(EPatchState.FAILED);
end;

procedure TFarmRunner.OnStart();
begin

end;

procedure TFarmRunner.OnComplete();
begin

end;

function TRSChat.ChatUntilOptions(): Boolean;
var
  Timeout: TCountdown;
begin
  Timeout.Init(10000);

  while (not Timeout.IsFinished) and (not ('Select' in Self.GetChatTitle())) and Self.ClickContinue() do
    Wait(0, 2500, wdLeft);

  Result := 'Select' in Self.GetChatTitle();
end;

procedure TFarmRunner.NoteItems();
var
  Slots, LepItems: TIntegerArray;
  Count, Slot, i: Int32;
  Items: TRSItemArray;
  PlayerBox: TBox;
  Item: TRSItem;
  LepPt: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteLn('Noting items at ', Self.CurrentPatch.Data.Name);

  for i := 0 to High(LeprechaunItems) do
  begin
    if Inventory.FindItem(item := LeprechaunItems[i], slot) then
    begin
      Slots += Slot;
      Items += Item;
      LepItems += i;
    end
  end;

  if Slots.Len() < 1 then
    Exit();

  for i := 0 to High(Slots) do
  begin
    RSInterface.Close();

    if ScriptWalker^.GetMyPos = Self.CurrentPatch.Data.LeprechaunCoords then
    begin
      PlayerBox := Mainscreen.GetPlayerBox();
      PlayerBox.Y1 := PlayerBox.Y1 - Floor(PlayerBox.Height / 2);
      LepPT := PlayerBox.Middle;
    end
    else if not Self.CurrentPatch.FindLeprechaun(LepPT) then
      Exit();

    Count := Inventory.CountItem(Items[i]);
    Inventory.SetSelectedSlot(Slots[i]);

    if SRL.Dice(65) then
      Mouse.HumanMove(LepPT)
    else
      Mouse.Move(LepPT);

    if Mainscreen.IsUpText('Tool') then
      Mouse.Click(MOUSE_LEFT)
    else if not ChooseOption.Select('Tool') then
    begin
      WriteLn('Failed to choose option leprechaun.');
      Inventory.SetSelectedSlot(-1);
      Exit();
    end;

    if not Mainscreen.DidRedClick() then
    begin
      WriteLn('Failed to find red click.');
      Inventory.SetSelectedSlot(-1);
      Exit();
    end;

    if SRL.Dice(65) and (i <> High(Slots)) then
    begin
      Wait(187, 317);
      Mouse.Move(Inventory.GetSlotBox(Slots[i+1]));
    end
    else if SRL.Dice(65) then
      Mouse.RandomMovement();

    if WaitUntil((Inventory.CountItem(Items[i]) = 0), 15, 10000) then
      Self.HarvestQuantities[LepItems[i]] += Count;

    Minimap.WaitPlayerMoving();
  end;
  Inventory.SetSelectedSlot(-1);
end;

procedure TFarmRunner.HandleDeadPatch(); begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)));

  if MainScreen.IsUpText('Dead') then
    Mouse.Click(MOUSE_LEFT)
  else if not ChooseOption.Select('Dead') then
  begin
    Mouse.RandomMovement();
    Exit();
  end;

  if not MainScreen.DidRedClick() then
    Exit();

  Wait(600, 800);
  Minimap.WaitPlayerMoving();
  Wait(600, 800);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if not WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue() or Self.CurrentPatch.IsEmpty), 15, 15000) then
    Exit();

  if Chat.HasContinue then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));

    if MainScreen.IsUpText('Dead') then
      Mouse.Click(MOUSE_LEFT)
    else if not ChooseOption.Select('Dead') then
    begin
      Mouse.RandomMovement();
      Exit();
    end;

    if not MainScreen.DidRedClick() then
      Exit();

    Wait(600, 800);
    Minimap.WaitPlayerMoving();
    Wait(600, 800);

    if not Self.CurrentPatch.Find(False) then
      Exit();

    WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue() or Self.CurrentPatch.IsEmpty), 15, 15000);
  end;

  Wait(250, 1000);
end;

procedure TFarmRunner.HandleDiseasedPatch();
begin
  Self.CurrentPatch.Skip := True;
end;

procedure TFarmRunner.DropBuckets();
var
  Tmp, Slots: TIntegerArray;
  i : Int32;
begin
  if not Inventory.FindItems(['Bucket'], Tmp) then
    Exit();

  for i := 0 to High(Tmp) do
  begin
    if SRL.CountColor(CTS2(4087132, 1, 3.61, 4.36), Inventory.GetSlotBox(Tmp[I])) > 2 then
      Continue()
    else
      Slots += Tmp[i];
  end;

  if Slots.Len < 1 then
    Exit();

  Inventory.ShiftDrop(Slots);
end;

procedure TFarmRunner.CompostPatch();
var
  CompostArray: TStringArray := ['Ultracompost', 'Bottomless compost bucket', ''];
  CompostItem: TRSItem := CompostArray[Self.CompostMethod];
  Slot, Attempts: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if not Self.CurrentPatch.Find then
  begin
    WriteLn('Could not find patch to compost!');
    Exit();
  end;

  WriteLn('Composting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.GetSelectedSlot() = -1 then
  begin
    if Inventory.FindItem(CompostItem, Slot) then
    begin

      Inventory.FindItem(CompostItem, Slot);
      if not Self.CurrentPatch.Find then
      begin
        WriteLn('Could not find patch to compost!');
        Exit();
      end;
    end;
  end;

  Wait(300, 500);

  for Attempts := 0 to 2 do
  begin
    if Attempts = 2 then
    begin
      WriteLn('Failed to find correct patch uptext while composting.');
      Antiban.RandomMouse();
      Wait(200, 500);
      Exit();
    end;

    if not Self.CurrentPatch.Find then
      Continue();

    if not Mainscreen.IsUpText(Self.CurrentPatch.PlantedUpText) then
    begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
      else
        Mouse.Move(Self.CurrentPatch.SearchBox);
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.PlantedUpText) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Break();
    end
    else if ChooseOption.Select(Self.CurrentPatch.PlantedUpText) then
      Break();
    Mouse.RandomMovement();
  end;

  if MainScreen.DidYellowClick then
  begin
    WriteLn('FOUND YELLOW CLICK!');
    Exit();
  end;

  if not WaitUntil((Chat.FindMessage('trea') or Chat.FindMessage('ming 2')), 50, 10000) then
  begin
    WriteLn('WaitUntil failed in composting step.');
    Exit();
  end;

  Self.NoteItems;

  Wait(600, 750);
  Self.DropBuckets;

  Wait(200, 400);
  Self.CurrentPatch.Complete := True;
end;

procedure TFarmRunner.Plant();
var
  CompostArray: TStringArray := ['Ultracompost', 'Bottomless compost bucket', ''];
  CompostItem: TRSItem := compostArray[Self.CompostMethod];
  Slot, Attempts: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  if not Self.CurrentPatch.Find() then
    Exit();

  WriteLn('Planting ' + ToStr(Self.CurrentPatch.Seed) + ' at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.GetSelectedSlot = -1 then
  begin
    if not Inventory.FindItem(Self.CurrentPatch.Seed, Slot) then
    begin
      WriteLn('Couldn''t find seed in inventory.');
      Self.CurrentPatch.Skip := True;
      Exit();
    end;

    if not Inventory.SetSelectedSlot(Slot) then
    begin
      WriteLn('Failed to select seed in inventory.');
      Exit();
    end;
  end;

  for Attempts := 0 to 2 do
  begin
    if Attempts = 2 then
    begin
      WriteLn('Failed to find correct patch uptext or choose option while planting.');
      Inventory.SetSelectedSlot(-1);
      Antiban.RandomMouse();
      Wait(200, 400);
      Exit();
    end;

    if not Self.CurrentPatch.Find() then
      Continue();

    if not MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) then
    begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
      else
        Mouse.Move(Self.CurrentPatch.SearchBox);
    end;

    if (Self.CurrentPatch.Data.PatchType <> EPatchType.HERB) and (Self.CurrentPatch.PlantedUpText in MainScreen.GetUpText.After('>')) then
    begin
      if MainScreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
        Self.Harvest()
      else
        Self.CompostPatch();

      Exit();
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Break();
    end
    else if ChooseOption.Select(Self.CurrentPatch.EmptyUpText) then
      Break();

    Mouse.RandomMovement();
  end;

  if not MainScreen.DidRedClick() then
    Exit();

  if WaitUntil(Minimap.IsPlayerMoving, 17, Random(713, 809)) then
    while Minimap.IsPlayerMoving do
      Wait(75);

  if Chat.HasContinue() then
  begin
    if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then
      Self.CompostPatch
    else
      Self.CurrentPatch.Complete := True;
    Exit();
  end;

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then
  begin
    if Inventory.FindItem(CompostItem, Slot) then
      Inventory.SetSelectedSlot(Slot);

    Wait(78, 208);

    if SRL.Dice(95) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  XPBar.EarnedXP();

  if WaitUntil(((not Self.CurrentPatch.IsEmpty) or XPBar.EarnedXP), 15, 10000) then
  begin
    Wait(338, 562);

    if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then
      Self.CompostPatch
    else
      Self.CurrentPatch.Complete := True;
  end;
end;

procedure TFarmRunner.Harvest();
var
  HarvestTimer: TCountdown;
  Slot: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Exit();

  WriteLn('Harvesting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull or (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) then
    Self.NoteItems();

  Minimap.WaitPlayerMoving();

  if not Self.CurrentPatch.Find() then
    Exit();

  if not Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
  begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  if Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
  begin
    Mouse.Click(MOUSE_LEFT);
  end
  else if not ChooseOption.Select(Self.CurrentPatch.HarvestUpText) then
  begin
    WriteLn('Failed to find harvest uptext or choose option.');
    Antiban.RandomRotate();
    Exit();
  end;

  if not Mainscreen.DidRedClick() then
  begin
    WriteLn('Failed to find red click.');
    Exit();
  end;

  if WaitUntil(Minimap.IsPlayerMoving, 17, Random(707, 803)) then
    while Minimap.IsPlayerMoving() do
      Wait(30);

  if not Self.CurrentPatch.Find(False) then
    Exit();

  if SRL.Dice(35) and Inventory.FindItem(Self.CurrentPatch.Seed, Slot) then
  begin
    Inventory.SetSelectedSlot(Slot);

    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.SearchBox))
    else
      Mouse.Move(Self.CurrentPatch.SearchBox);
  end;

  HarvestTimer.Init(4000);

  while not HarvestTimer.IsFinished() do
  begin
    if XPBar.EarnedXP() then
      HarvestTimer.Restart();

    if Inventory.IsFull() then
    begin
      Inventory.SetSelectedSlot(-1);
      Wait(532, 718);
      Self.NoteItems();
      Exit();
    end;

    if HarvestTimer.IsFinished() or Self.CurrentPatch.IsEmpty() then
    begin
      Plant();
      Exit();
    end;

    WaitEx(500, 450);

    if Self.CurrentPatch.Skip = True then
      Break();
  end;
end;

procedure TFarmRunner.TeleportTo(TravelMethod: ETravelMethod; ConfirmPos: Boolean);
begin
  WriteLn('Teleporting to ' + Self.CurrentPatch.Data.Name);

  if not RSClient.IsLoggedIn() then
    Exit();

  Inventory.SetSelectedSlot(-1);

  if ScriptWalker^.GetMyPos in Self.CurrentPatch.Data.MapCoords then
    Exit();

  case TravelMethod of
    ETravelMethod.CAMELOT_TELEPORT: Magic.CastSpell(ERSSpell.CAMELOT_TELEPORT, 'Cast');
    ETravelMethod.HOUSE_TELEPORT: Magic.CastSpell(ERSSpell.TELEPORT_TO_HOUSE, 'Outside');
    ETravelMethod.FALADOR_TELEPORT: Magic.CastSpell(ERSSpell.FALADOR_TELEPORT, 'Cast');
    ETravelMethod.ARDOUGNE_TELEPORT: Magic.CastSpell(ERSSpell.ARDOUGNE_TELEPORT, 'Cast');
  end;

  WaitEx(2750, 500);

  if not ConfirmPos then
    Exit();

  if not WaitUntil((ScriptWalker^.GetMyPos in Self.CurrentPatch.Data.MapCoords), 10, 10000) then
    Exit();

  if Inventory.IsFull() then
    Self.NoteItems;
end;

procedure TFarmRunner.Report();
begin
  WriteLn(SRL.TimeStamp() + ':[' + 'Farm' + ']: ' + 'Thanks to XJ and Student, we finished another farm run!');
end;

operator in(Left: TBox; Right: TBoxArray): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Right) do
    if Left = Right[i] then
      Exit(True);
end;

procedure TFarmRunner.Init();
const
  Runes: TRSItemArray := ['Air rune', 'Water rune', 'Earth rune', 'Law rune'];
var
  i, u, h, t: Int32;
  RSW: TRSWalker;
  Tmp: TBoxArray;
  Item: TRSItem;
begin
  LeprechaunItems := ['Guam leaf', 'Marrentill', 'Tarromin', 'Harralander', 'Ranarr weed', 'Toadflax',
                      'Irit leaf', 'Avantoe', 'Kwuarm', 'Snapdragon', 'Cadantine', 'Lantadyme',
                      'Dwarf weed', 'Torstol', 'Limpwurt root', 'Potato', 'Onion', 'Cabbage', 'Tomato', 'Sweetcorn',
                      'Strawberry', 'Watermelon', 'Snape grass', 'White berries', 'Potato cactus', 'Cactus spine', 'Giant seaweed'];

  Self.InactivityTimer.Init(6 * ONE_MINUTE);
  SetLength(Self.HarvestQuantities, Length(LeprechaunItems));

  t := Random(75, 200);

  for Item in Runes do
  begin
    Self.FarmItems += Item;
    Self.FarmItemAmounts += t;
  end;

  if Self.HosidiusHerb then
  begin
    Self.AddPatch(EFarmPatch.HOSIDIOUS_HERB, ETravelMethod.HOUSE_TELEPORT, Self.HerbSeed);
    Inc(h);
  end;

  if Self.ArdougneHerb then
  begin
    Self.AddPatch(EFarmPatch.ARDY_HERB, ETravelMethod.ARDOUGNE_TELEPORT, Self.HerbSeed);
    Inc(h);
  end;

  if Self.FaladorHerb then
  begin
    Self.AddPatch(EFarmPatch.FALLY_HERB, ETravelMethod.FALADOR_TELEPORT, Self.HerbSeed);
    Inc(h);
  end;

  if Self.CatherbyHerb then
  begin
    Self.AddPatch(EFarmPatch.CATHERBY_HERB, ETravelMethod.CAMELOT_TELEPORT, Self.HerbSeed);
    Inc(h);
  end;

  if Self.HosidiusFlower then
  begin
    Self.AddPatch(EFarmPatch.HOSIDIOUS_FLOWER, ETravelMethod.HOUSE_TELEPORT, 'Limpwurt seed');
    Inc(u);
  end;

  if Self.ArdougneFlower then
  begin
    Self.AddPatch(EFarmPatch.ARDY_FLOWER, ETravelMethod.ARDOUGNE_TELEPORT, 'Limpwurt seed');
    Inc(u);
  end;

  if Self.FaladorFlower then
  begin
    Self.AddPatch(EFarmPatch.FALLY_FLOWER, ETravelMethod.FALADOR_TELEPORT, 'Limpwurt seed');
    Inc(u);
  end;

  if Self.CatherbyFlower then
  begin
    Self.AddPatch(EFarmPatch.CATHERBY_FLOWER, ETravelMethod.CAMELOT_TELEPORT, 'Limpwurt seed');
    Inc(u);
  end;

  case Self.CompostMethod of
    ECompostMethod.BOTTOMLESS:
    begin
      Self.FarmItems += 'Bottomless compost bucket';
      Self.FarmItemAmounts += 1;
    end;

    ECompostMethod.ULTRA:
    begin
      Self.FarmItems += 'Ultracompost';
      Self.FarmItemAmounts += u;
    end;
  end;

  Self.FarmItems += 'Spade';
  Self.FarmItemAmounts += 1;

  if Self.MSecs then
  begin
    FarmItems += 'Magic secateurs';
    FarmItemAmounts += 1;
  end;

  if u > 0 then
  begin
    Self.FarmItems += 'Limpwurt seed';
    Self.FarmItemAmounts += u;
  end;

  if h > 0 then
  begin
    Self.FarmItems += Self.HerbSeed;
    Self.FarmItemAmounts += h;
  end;

  if not Self.BDibber then
  begin
    Self.FarmItems += 'Seed dibber';
    Self.FarmItemAmounts += 1;
  end;

  for i := 0 to High(Self.Patches) do
    if not (Self.Patches[i].Data.MapCoords in Tmp) then
      Tmp += Self.Patches[i].Data.MapCoords;

  if ScriptWalker = nil then
  begin
    RSW.SetupRegions(Tmp);
    RSW.AdaptiveWalk := True;
  end
  else
    ScriptWalker^.AddRegions(tmp);

  if StartWithRun then
    Self.ReadyTimer.Init(0)
  else
    Self.ReadyTimer.Init(Self.GetNextTime());

  (*// Boolean fields
  WriteLn('Hosidius Flower: ', Self.HosidiusFlower);
  WriteLn('Hosidius Herb: ', Self.HosidiusHerb);
  WriteLn('Falador Flower: ', Self.FaladorFlower);
  WriteLn('Falador Herb: ', Self.FaladorHerb);
  WriteLn('Ardougne Flower: ', Self.ArdougneFlower);
  WriteLn('Ardougne Herb: ', Self.ArdougneHerb);
  WriteLn('Catherby Flower: ', Self.CatherbyFlower);
  WriteLn('Catherby Herb: ', Self.CatherbyHerb);
  WriteLn('BDibber: ', Self.BDibber);
  WriteLn('Start With Run: ', Self.StartWithRun);
  WriteLn('MSecs: ', Self.MSecs);

  // Arrays
  WriteLn('Farm Item Amounts: ', ToStr(Self.FarmItemAmounts));
  WriteLn('Return Item Amounts: ', ToStr(Self.ReturnItemAmounts));

  WriteLn('Herb Seed: ', ToStr(Self.HerbSeed));
  WriteLn('Compost Method: ', ToStr(Self.CompostMethod));

  // Complex arrays
  WriteLn('Patches Length: ', Length(Self.Patches));
  WriteLn('Farm Items Length: ', Length(Self.FarmItems));
  WriteLn('Return Items Length: ', Length(Self.ReturnItems));*)
end;

function TFarmRunner.WithdrawNextRun(): Boolean;
var
  Item: TRSBankItem;
  i: Int32;
begin
  if not Bank.IsOpen() then
    Exit(False);

  for i := 0 to High(Self.FarmItems) do
  begin
    Item := TRSBankItem.Setup(Self.FarmItems[i], Self.FarmItemAmounts[i], False);
    Bank.WithdrawItem(Item, False);
    WaitEx(500, 450);
  end;

  Result := WaitUntil(Inventory.ContainsAll(Self.FarmItems), 500, 2750);

  WaitEx(500, 450);
end;

procedure TFarmRunner.Run();
var
  AntibanMinZ, AntibanMaxZ: Int32;
  State: EPatchState;
  FailedCount: Int32;
begin
  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  Self.DebugLn('Starting a run');

  Self.Runtime.Start();

  AntibanMinZ := Antiban.MinZoom;
  AntibanMaxZ := Antiban.MaxZoom;
  Antiban.MinZoom := 17;
  Antiban.MaxZoom := 23;
  Mainscreen.SetHighestPitch;
  Options.SetZoomLevel(Random(17, 23));

  Self.OnStart();

  Self.LastXPRead := XPBar.Read();
  Self.InactivityTimer.Restart();

  if not RSClient.IsLoggedIn() then
    Login.LoginPlayer();

  for Self.CurrentPatch in Self.Patches do
  begin
    if not RSClient.IsLoggedIn() then
      Login.LoginPlayer();

    repeat
      State := Self.CurrentPatch.GetState();

      if FailedCount = 8 then
        State := EPatchState.SKIP;

      if State <> EPatchState.FAILED then
        FailedCount := 0;

      case State of
        EPatchState.HARVEST: Self.Harvest;
        EPatchState.PLANT: Self.Plant;
        EPatchState.COMPOST: Self.CompostPatch;
        EPatchState.DISEASED: Self.HandleDiseasedPatch;
        EPatchState.DEAD: Self.HandleDeadPatch;
        EPatchState.TELEPORT_TO: Self.TeleportTo(Self.CurrentPatch.TravelMethod, True);
        EPatchState.NOTE_ITEMS: Self.NoteItems;
        EPatchState.FAILED: Inc(failedCount);
        EPatchState.COMPLETE:
        begin
          WriteLn('Patch complete.');
          Inc(Self.PatchesCompleted);
          Break();
        end;
        EPatchState.SKIP:
        begin
          WriteLn('Skipping patch.');
          Inc(Self.PatchesSkipped);
          Break();
        end;
      end;

      if XPBar.EarnedXP() then
        InactivityTimer.Restart();

    until InactivityTimer.IsFinished();

    Self.CurrentPatch.Skip := Self.CurrentPatch.Complete := False;
  end;

  if InactivityTimer.IsFinished() then
    TerminateScript('Terminating due to inactivity.');

  Inc(Self.RunsComplete);

  Antiban.MinZoom := AntibanMinZ;
  Antiban.MaxZoom := AntibanMaxZ;

  Self.OnComplete();

  Self.Runtime.Pause();

  Self.XPGained += XPBar.Read() - Self.LastXPRead;
  Self.Report();
end;

procedure TFarmRunner.DoFarmRun();
begin
  if not ReadyTimer.IsFinished() then
    Exit();

  Self.Run();

  ReadyTimer.Init(Self.GetNextTime());
end;
